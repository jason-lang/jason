// Copyright (C) 2003  Rafael H. Bordini, Jomi F. Hubner, et al.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//----------------------------------------------------------------------------


options {
   FORCE_LA_CHECK=true;
   STATIC=false;
   IGNORE_CASE=false;
   UNICODE_INPUT=true;
}

PARSER_BEGIN(as2j)

  package jason.asSyntax.parser;

  import java.util.*;
  import java.io.*;
  import java.util.logging.*;
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;

  import jason.*;
  import jason.asSemantics.*;
  import jason.bb.*;
  import jason.asSyntax.*;
  import jason.asSyntax.directives.*;
  import jason.asSyntax.ArithExpr.ArithmeticOp;
  import jason.asSyntax.LogExpr.LogicalOp;
  import jason.asSyntax.RelExpr.RelationalOp;
  import jason.asSyntax.PlanBody.BodyType;
  import jason.asSyntax.Trigger.TEOperator;
  import jason.asSyntax.Trigger.TEType;
  import jason.util.*;

  public class as2j {
    private String    asSource = "";
    private Agent     curAg    = null;
    private int       annotationBeginLine = -1;

    private Atom      namespace     = Literal.DefaultNS;
    private Atom      thisnamespace = Literal.DefaultNS;

    private DirectiveProcessor directiveProcessor = new DirectiveProcessor();
    private NameSpace nsDirective = (NameSpace)directiveProcessor.getInstance("namespace");

    private static Logger logger = Logger.getLogger("aslparser");
    private static Set<String> parsedFiles = new HashSet<String>();
    private static Config config = Config.get(false);
    private static Pattern patternUnnamedWithId = Pattern.compile("_(\\d+)(.*)");

    public void setAg(Agent ag) { curAg = ag; }
    public void setNS(Atom  ns) { namespace = ns; thisnamespace = ns; }
    public Atom getNS()         { return namespace; }

    public void setASLSource(String src) { asSource = src; }

    private String getSourceRef(SourceInfo s) {
        if (s == null)
            return "[]";
        else
            return "["+s.getSrcFile()+":"+s.getBeginSrcLine()+"]";
    }
    private String getSourceRef(DefaultTerm t) {
        return getSourceRef( t.getSrcInfo());
    }
    private String getSourceRef(Object t) {
        if (t instanceof DefaultTerm)
            return getSourceRef((DefaultTerm)t);
        else if (t instanceof SourceInfo)
            return getSourceRef((SourceInfo)t);
        else
            return "[]";
    }

	private InternalActionLiteral checkInternalActionsInContext(LogicalFormula f, Agent ag) throws Exception {
	    if (f != null) {
	        if (f instanceof InternalActionLiteral) {
	            InternalActionLiteral ial = (InternalActionLiteral)f;
	            if (! ial.getIA(ag).canBeUsedInContext())
	               return ial;
	        } else if (f instanceof LogExpr) {
	            LogExpr le = (LogExpr)f;
	            InternalActionLiteral ial = checkInternalActionsInContext(le.getLHS(), ag);
	            if (ial != null)
	                return ial;
	            if (!le.isUnary())
	                return checkInternalActionsInContext(le.getRHS(), ag);
	        }
        }
        return null;
    }

    private ArithFunction getArithFunction(Literal l) {
        ArithFunction af = null;
        if (curAg != null)
           // try to find the function in agent register
           af = curAg.getFunction(l.getFunctor(), l.getArity());
        if (af == null)
           // try global function
           af = FunctionRegister.getFunction(l.getFunctor(), l.getArity());
        return af;
    }

    private Term changeToAtom(Object o) {
        Term u = (Term)o;
        if (u == Literal.LTrue)
            return u;
        if (u == Literal.LFalse)
            return u;
        if (u.isAtom()) {
           if (((Atom)u).getFunctor().equals("default"))
              return Literal.DefaultNS;
           else if (((Atom)u).getFunctor().equals("this_ns"))
              return thisnamespace;
           else
              return new Atom((Literal)u);
        }
        return u;
    }

  }

PARSER_END(as2j)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")?>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

// Note: i do not why, but vars must be defined before TK_BEGIN and END
TOKEN : {
  <VAR : (<UP_LETTER> (<CHAR>)*) >
}

TOKEN : {
// Predefined
  <TK_TRUE:   "true">
| <TK_FALSE:  "false">
| <TK_NOT:    "not">
| <TK_NEG:    "~">
| <TK_INTDIV: "div">
| <TK_INTMOD: "mod">
| <TK_BEGIN:  "begin" >
| <TK_END:    "end" >
| <TK_LABEL_AT: "@"> // special chars

| <TK_IF:     "if" >
| <TK_ELSE:   "else" >
| <TK_ELIF:   "elif" >
| <TK_FOR:    "for" >
| <TK_WHILE:  "while" >

| <TK_PAND:  "|&|" >
| <TK_POR:   "|||" >

| <TK_LEFT_ARROW: "<-" >
| <TK_GOAL_CONDITION: "<:" >
| <TK_RULE_SEP: ":-" >
| <TK_NS_SEP: "::" >

// Numbers
|  <NUMBER: ["0"-"9"] (["0"-"9"])*
          | (["0"-"9"])* "." (["0"-"9"])+ (["e","E"] (["+","-"])? (["0"-"9"])+)?
          | (["0"-"9"])+ (["e","E"] (["+","-"])? (["0"-"9"])+) >

// Strings
|  <STRING: "\"" ( ~["\"","\\","\n","\r"]
                 | "\\" ( ["n","t","b","r","f","\\","\'","\""]
                        | ["0"-"7"] (["0"-"7"])?
                        | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">

// Identifiers
|  <ATOM      : (<LC_LETTER> | "." <CHAR>) (<CHAR> | "." <CHAR>)*
                | ("'" (~["'"])* "'" ) >
                //{ if (image.charAt(0) == '\'') matchedToken.image = image.substring(1, lengthOfMatch-1); }
|  <UNNAMEDVARID: ("_" (<DIGIT>)+ (<CHAR>)*) >
|  <UNNAMEDVAR: ("_" (<CHAR>)*) >
|  <CHAR      : (<LETTER> | <DIGIT> | "_")>
|  <LETTER    : ( <LC_LETTER> | <UP_LETTER> )>
|  <LC_LETTER : ["a"-"z"]>
|  <UP_LETTER : ["A"-"Z"]>
|  <DIGIT     : ["0"-"9"]>
}

/* AgentSpeak Grammar */

boolean agent(Agent a) throws jason.JasonException :
{
  curAg = a;
}
{
  ( agent_component(a) )* <EOF>   {
                                    if (a != null) parsedFiles.add(a.getASLSrc());
                                    return true;
                                  }
}


void agent_component(Agent a) throws jason.JasonException :
{
  Literal b;
  Literal g;
  Plan    p;
}
{
  (
    directive(a)
    | b = belief()          { if (a != null) a.addInitialBel(b); }
    | g = initial_goal()    { if (a != null) a.addInitialGoal(g); }
    | p = plan()            { if (a != null) {
                                p.setSourceFile(asSource);
                                a.getPL().add(p);
                                // warning only not parsed files
                                if (config.getBoolean(Config.WARN_SING_VAR) && !parsedFiles.contains(asSource)) {
                                  List<VarTerm> singletonVars = p.getSingletonVars();
                                  if (singletonVars.size() > 0) {
                                    logger.warning(getSourceRef(p.getSrcInfo())+" warning: the plan for event '"+p.getTrigger()+"' has the following singleton variables: "+singletonVars);
                                  }
                                }
                              }
                            }
  )
}


/* Directive */
boolean directive(Agent outerAg) throws jason.JasonException :
{
  Pred dir = null;
  Agent resultOfDirective = null;
  Agent bakAg = curAg;
  Atom oldNS = null;
}
{
  "{"
  	(
  		<TK_BEGIN> dir = directive_arguments() "}"
                                    { Agent innerAg = new Agent(); innerAg.initAg();
                                      dir = new Pred(namespace, dir);
                                      Directive d = directiveProcessor.getInstance(dir);
                                      d.begin(dir,this);
                                    }

        ( LOOKAHEAD(2) agent_component(innerAg) )* "{" <TK_END> "}"
                                    {
                                      resultOfDirective = d.process(dir, outerAg, innerAg);
                                      d.end(dir,this);
                                    }
  		|
        dir = directive_arguments() "}"
                                    { dir = new Pred(namespace, dir);
                                      Directive d = directiveProcessor.getInstance(dir);
                                      d.begin(dir, this); // to declare the namespace as local
                                      resultOfDirective = d.process(dir, outerAg, null);
                                      d.end(dir, this);
                                    }
  	)
                                    { if (resultOfDirective != null && outerAg != null) {
                                        // import bels, plans and initial goals from agent resultOfDirective
                                        outerAg.importComponents(resultOfDirective);
                                      }
                                      curAg = bakAg;
                                      return false;
                                    }
}


Pred directive_arguments() :
{
  Token K; Pred p; List l; ListTerm lt;
  Atom ons = namespace; namespace = Literal.DefaultNS; // do not replace abstract namespace for terms
}
{
  K = <ATOM>              { p = new Pred(K.image);
                            p.setSrcInfo(new SourceInfo(asSource, K.beginLine));
                          }
  [
    "(" l = terms() ")"   { p.setTerms(l); }
  ]
  [
    lt = list()           { p.setAnnots(lt); }
  ]
                          { namespace = ons;
                            return p;
                          }
}


/* Beliefs & Rules */
Literal belief() : { Literal h; Object t; }
{
    h=literal()              { if (h.isVar()) {
                                  throw new ParseException(getSourceRef(h)+" variables cannot be beliefs!");
                               }
                             }
    [
      <TK_RULE_SEP> t = log_expr()
                             { h = new Rule(h,(LogicalFormula)t);
                               // warning only not parsed files
                               if (config.getBoolean(Config.WARN_SING_VAR) && !parsedFiles.contains(asSource)) {
                                  List<VarTerm> singletonVars = h.getSingletonVars();
                                  if (singletonVars.size() > 0) {
                                     logger.warning(getSourceRef(h)+" warning: the rule with head '"+((Rule)h).headClone()+"' has the following singleton variables: "+singletonVars);
                                  }
                               }
                             }
    ]
    "."                      { return h; }
}


/* Initial goals */
Literal initial_goal() : { Literal g; }
{
  "!" g=literal() "."    { if (g.isVar()) {
                                  throw new ParseException(getSourceRef(g)+". a variable cannot be a goal!");
                           }
                           return g;
                         }
}


/* Plan */
Plan plan() :
{
  Token k = null;
  Pred L = null; Literal L2;
  Trigger T;
  Object C = null;
  Object GC = null;
  PlanBody B = null;
  List sps = null; Plan sp;
  int start = -1, end = -1;
}
{
  [
    L2 = plan_annotation()    {
                                start = annotationBeginLine;
                                L = new Pred(L2);
                              }
  ]
  T = trigger()
  [ k = ":" C = log_expr()                   { if (start == -1) start = k.beginLine; } ]
  [ k = <TK_GOAL_CONDITION> GC = log_expr()  { if (start == -1) start = k.beginLine; } ] // NEW ER syntax for goal condition
  [ k = <TK_LEFT_ARROW> B = plan_body()      { if (start == -1) start = k.beginLine; } ]
  k = "."                                    { if (start == -1) start = k.beginLine; }

  [ LOOKAHEAD(4) // to avoid conflict with directive "{ begin ... }
    "{" // NEW ER syntax for sub plans
	                               { sps = new ArrayList(); }
	    (
	        sp = plan()            { sps.add(sp); }
	    )*
	"}"
   ]

                    {
                      if (k != null) end = k.beginLine;
                      InternalActionLiteral ial = null;
                      try { ial = checkInternalActionsInContext((LogicalFormula)C, curAg); } catch (Exception e) {}
                      if (ial != null)
                        throw new ParseException(getSourceRef(ial)+" The internal action '"+ial+"' can not be used in plan's context!");
                      if (B != null && B.getBodyTerm().equals(Literal.LTrue))
                        B = (PlanBody)B.getBodyNext();
                      Plan p = new Plan(L,T,(LogicalFormula)C, B);
                      p.setSrcInfo(new SourceInfo(asSource,start,end));

					  // NEW ER syntax
                      p.setGoalCondition((LogicalFormula)GC);
                      if (sps != null)
                     	for (Object o: sps)
                     		try {
                     		    p.addSubPlan((Plan)o);
                     		} catch (Exception e) {
                     			e.printStackTrace();
                     		}

                      return p;
                    }
}


Literal plan_annotation() :
{
  Token k; Literal L; Token at = null; ListTerm annots = null;
}
{
  k = <TK_LABEL_AT> ( ( at = <ATOM> | at = <TK_BEGIN> | at = <TK_END> ) [ annots = list() ] | annots = list() )

                              {
                                if(at == null) {
                                  if (curAg != null) {
                                    L = curAg.getPL().getUniqueLabel();
                                  } else {
                                    L = new Pred("undefined");
                                  }
                                } else {
                                  L = new Pred(namespace, at.image);
                                  L.setSrcInfo(new SourceInfo(asSource, at.beginLine));
                                }
                                if (annots != null) {
                                  L.addAnnots( annots.getAsList() );
                                }
                                annotationBeginLine = k.beginLine;
                                return L;
                              }
}


/* Trigger */
Trigger trigger() :
               {
               		TEOperator teOp;
			    	TEType     teType = TEType.belief;
				 	Literal F;
               }
{
  ( "+"        { teOp = TEOperator.add; }
  | "-"        { teOp = TEOperator.del; }
  | "^"        { teOp = TEOperator.goalState; }
  )

  [ ( "!"      { teType = TEType.achieve; }
    | "?"      { teType = TEType.test; }
    )
  ]

  F=literal()  { return new Trigger(teOp,teType,F.forceFullLiteralImpl()); }
}


/* Plan body */
PlanBody plan_body() :
{
  PlanBody F; PlanBody R = null;
}
{
  ( F = plan_body_term() [ ";" [ R = plan_body() ] ] | F = statement() [ ";" ] [ R = plan_body() ] )

          {
            if (R != null) {
              F.setBodyNext( R );
            }
            return F;
          }
}


PlanBody plan_body_term() : { PlanBody F; PlanBody R = null; }
{
F = plan_body_factor()

[ <TK_POR> R = plan_body_term() ]

                            {
                               if (R == null)
                                  return (PlanBody)F;
                               try {
                                  Structure s = ASSyntax.createStructure(".fork", jason.stdlib.fork.aOr, (Term)F);
                                  if (R.toString().startsWith(".fork(or,")) {
                                     // if R is another fork or, put they args into this fork
                                     InternalActionLiteral ial = (InternalActionLiteral)R.getBodyTerm();
                                     if (ial.getIA(curAg) instanceof jason.stdlib.fork) {
                                        for (int i=1; i<ial.getArity(); i++) {
                                           s.addTerm(ial.getTerm(i));
                                        }
                                     }
                                  } else {
                                     s.addTerm(R);
                                  }

                                  Literal stmtLiteral = new InternalActionLiteral(s, curAg);
                                  stmtLiteral.setSrcInfo( ((Term)F).getSrcInfo() );
                                  return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
                               } catch (Exception e) {
                                  e.printStackTrace();
                               }
                            }
}


PlanBody plan_body_factor() :
{
  Object F; PlanBody R = null;
}
{ F = body_formula()   { if (!(F instanceof PlanBody)) throw new ParseException(getSourceRef(F)+" "+F+" is not a body literal!"); } // DÃºvida: Existe algum controle aqui que envolvia os if/for/while?
  [ <TK_PAND> R = plan_body_factor() ]
                        {
                          if (R == null)
                            return (PlanBody)F;
                          try {
                            Structure s = ASSyntax.createStructure(".fork", jason.stdlib.fork.aAnd, (Term)F);
                            if (R.toString().startsWith(".fork(and,")) {
                              // if R is another fork and, put they args into this fork
                              InternalActionLiteral ial = (InternalActionLiteral)R.getBodyTerm();
                              if (ial.getIA(curAg) instanceof jason.stdlib.fork) {
                                for (int i=1; i<ial.getArity(); i++) {
                                  s.addTerm(ial.getTerm(i));
                                }
                              }
                            } else {
                              s.addTerm(R);
                            }
                            Literal stmtLiteral = new InternalActionLiteral(s, curAg);
                            stmtLiteral.setSrcInfo( ((Term)F).getSrcInfo() );
                            return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
                          } catch (Exception e) {
                            e.printStackTrace();
                          }
                        }
}


PlanBody statement() :
{
  PlanBody B;
}
{
  ( B = stmtIF() | B = stmtFOR() | B = stmtWHILE() )
    { return B; }
}


PlanBody stmtIF() :    { PlanBody B; }
{
   <TK_IF>
   B = stmtIFCommon()
   { return B; }
}


PlanBody stmtIFCommon() :
{
  Object B; PlanBody pb1 = null; PlanBody pb2 = null; Literal stmtLiteral = null;
}
{
  "(" B = log_expr() ")" "{" [ pb1 = stmt_body() ] "}" [ <TK_ELIF> pb2 = stmtIFCommon() | <TK_ELSE> "{" [ pb2 = stmt_body() ] "}" ]

                        {
                          try {
                            if (pb1 == null) {
                              pb1 = new PlanBodyImpl();
                            }
                            if (pb2 == null) {
                              stmtLiteral = new InternalActionLiteral(ASSyntax.createStructure(".if_then_else", (Term)B, pb1), curAg);
                            } else {
                              stmtLiteral = new InternalActionLiteral(ASSyntax.createStructure(".if_then_else", (Term)B, pb1, pb2), curAg);
                            }
                            stmtLiteral.setSrcInfo( ((Term)B).getSrcInfo() );
                            return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
                          } catch (Exception e) {
                            e.printStackTrace();
                          }
                        }
}


PlanBody stmtFOR() :
{
  Object B; PlanBody pb = null; Literal stmtLiteral;
}
{
   <TK_FOR> "(" B = log_expr() ")" "{" [ pb = stmt_body() ] "}"

                        {
                          try {
                            if (pb == null) {
                              pb = new PlanBodyImpl();
                            }
                            stmtLiteral = new InternalActionLiteral(ASSyntax.createStructure(".foreach", (Term)B, pb), curAg);
                            stmtLiteral.setSrcInfo( ((Term)B).getSrcInfo() );
                            return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
                          } catch (Exception e) {
                            e.printStackTrace();
                          }
                        }
}


PlanBody stmtWHILE() :
{
  Object B; PlanBody pb = null; Literal stmtLiteral;
}
{
  <TK_WHILE> "(" B = log_expr() ")" "{" [ pb = stmt_body() ] "}"

                        {
                          try {
                            if (pb == null) {
                              pb = new PlanBodyImpl();
                            }
                            stmtLiteral = new InternalActionLiteral(ASSyntax.createStructure(".loop", (Term)B, pb), curAg);
                            stmtLiteral.setSrcInfo( ((Term)B).getSrcInfo() );
                            return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
                          } catch (Exception e) {
                            e.printStackTrace();
                          }
                        }
}


PlanBody stmt_body() :
{
  PlanBody B = null;
}
{
  B = plan_body()   { return B; }
}


Object body_formula() :
{
  BodyType formType = BodyType.action;  Object B;
}
{
  (
    (
      (
        "!"               { formType = BodyType.achieve; }
        | "!!"            { formType = BodyType.achieveNF; }
      )
      B = literal()
    )
    |
    (
        [
          "?"             { formType = BodyType.test; }
          |
          "+"             { formType = BodyType.addBel; }
            [
              "+"         { formType = BodyType.addBelNewFocus; }
              | "<"       { formType = BodyType.addBel; }
              | ">"       { formType = BodyType.addBelEnd; }
            ]
          |
          "-"             { formType = BodyType.delBel; }
            [
              "+"         { formType = BodyType.delAddBel; }
              | "-"       { formType = BodyType.delBelNewFocus; }
            ]
        ]

        // look for "(!g3 ||| !g4)" against "(X > 2)" / plan body agains log expression
        ( LOOKAHEAD(log_expr())
          B = log_expr()
        |
          LOOKAHEAD("(" plan_body())
          "(" B = plan_body() ")"
        )
    )
  )


                        {
                          if (formType == BodyType.action && B instanceof RelExpr) {
                            return new PlanBodyImpl(BodyType.constraint, (RelExpr)B); // constraint
                          }
                          if (B instanceof Plan) {
                            try {
                              InternalActionLiteral ia = null;
                              String ias = "";
                              if (formType == BodyType.delBel) {
                                ia = new InternalActionLiteral(ASSyntax.createStructure(".remove_plan", (Term)B), curAg);
                              } else if (formType == BodyType.addBel) {
                                ia = new InternalActionLiteral(ASSyntax.createStructure(".add_plan", (Term)B, BeliefBase.ASelf, ASSyntax.createAtom("begin")), curAg);
                              } else if (formType == BodyType.addBelEnd) {
                                ia = new InternalActionLiteral(ASSyntax.createStructure(".add_plan", (Term)B, BeliefBase.ASelf, ASSyntax.createAtom("end")), curAg);
                              } else {
                                throw new ParseException(getSourceRef(B)+" Wrong combination of operator "+formType+" and plan.");
                              }
                              return new PlanBodyImpl(BodyType.internalAction, ia);
                            } catch (Exception e) {
                              e.printStackTrace();
                            }
                          }
                          if (B instanceof InternalActionLiteral && formType != BodyType.action) {
                            throw new ParseException(getSourceRef(B)+" Wrong combination of operator "+formType+" and internal action "+B+".");
                          }
                          if (B instanceof Literal) {
                            if ( ((Literal)B).isInternalAction() )
                              formType = BodyType.internalAction;
                            return new PlanBodyImpl(formType, (Literal)B);
                          } else {
                            if (formType == BodyType.test) {
                              if (B instanceof LogicalFormula)
                                return new PlanBodyImpl(BodyType.test, (Term)B);  // used in ?(a & b)
                              else
                                throw new ParseException(getSourceRef(B)+" The argument for ? is not a logical formula.");
                            } else {
                              return B;
                            }
                          }
                        }
}


Term rule_plan_term() :
{
  Trigger T = null; Object C = null; PlanBody B = null, B1 = null; Plan P = null;
  boolean pb = true; // pb = "only plan body"
  Pred L = null; Token K; ListTerm lt;
  Literal h = null; Object t = null;
  Boolean isRule = false; Token S = null;
}
{
  "{"
    [ LOOKAHEAD(2)
      [ L = plan_term_annotation()                              { pb = false; } ]
          T = trigger()                                         { if (T.getType() != TEType.belief) pb = false; }
            [ ":" C = log_expr()                                { pb = false; } ]
            [
              (
                ";" [ B = plan_body() ]                         { if (!pb) throw new ParseException(getSourceRef(T)+" Wrong place for ';'"); }
                | <TK_LEFT_ARROW> B = plan_body()               { pb = false; }
              )
            ]
      |
        B = plan_body()
          [
            S = <TK_RULE_SEP> t = log_expr()                    { isRule = true; }
          ]
    ]
  "}"
                                                                {   if (isRule) {
                                                                      Object li = B.getBodyTerm();
                                                                      if (!(li instanceof Literal) || B.getBodyNext() != null)
                                                                        throw new ParseException(getSourceRef(S)+" Wrong place for Rule");
                                                                      Rule r = new Rule((Literal)li,(LogicalFormula)t);
                                                                      r.setAsTerm(true);
                                                                      return r;
                                                                    }
                                                                    // the plan body case
                                                                    if (T != null) {
                                                                      // handle the case of "+a1", parsed as TE, need to be changed to plan's body
                                                                      // handle the case of "+a1; +a2", parsed as "TE; Body"
                                                                      if (pb && L == null) {
                                                                        if (T.isAddition())
                                                                          B1 = new PlanBodyImpl(BodyType.addBel, T.getLiteral(), true);
                                                                        else
                                                                          B1 = new PlanBodyImpl(BodyType.delBel, T.getLiteral(), true);
                                                                        if (B != null)
                                                                          B1.setBodyNext(B);
                                                                        return B1;
                                                                      }
                                                                      if (C == null && B == null && L == null) {
                                                                        // handle the case of a single trigger
                                                                        T.setAsTriggerTerm(true);
                                                                        return T;
                                                                      } else {
                                                                        // handle the case of a entire plan
                                                                        Plan p = new Plan(L,T,(LogicalFormula)C, B);
                                                                        p.setSrcInfo(T.getSrcInfo());
                                                                        p.setAsPlanTerm(true);
                                                                        return p;
                                                                      }
                                                                    }

                                                                    // the case of a simple plan body term
                                                                    if (B == null)
                                                                      B = new PlanBodyImpl();
                                                                    B.setAsBodyTerm(true);
                                                                    return B;
                                                                }
}

Pred plan_term_annotation() :
{
  Pred p = null; Token K = null; ListTerm annots = null;
}
{
  <TK_LABEL_AT> ( ( K = <ATOM> | K = <TK_BEGIN> | K = <TK_END> ) [ annots = list() ] | p = var(Literal.DefaultNS) | annots = list() )

                        {
                          if (p == null) {
                            if (K != null) {
                              p = new Pred(K.image);
                              p.setSrcInfo(new SourceInfo(asSource, K.beginLine));
                            } else {
                              p = new Pred("undefined");
                            }
                            if (annots != null) {
                              p.addAnnots(annots.getAsList());
                            }
                          }
                          return p;
                        }
}


/* Literal */
Literal literal() :
{
  Pred F = null; Pred V; Token k; boolean type = Literal.LPos; Atom NS = namespace;
}
{
  (
    [ LOOKAHEAD(namespace()) NS = namespace() ]
    [
      <TK_NEG>                  { type = Literal.LNeg; }
    ]
    (
      F = pred()
      | V = var(NS)             { VarTerm vt = (VarTerm)V;
                                  vt.setNegated(type);
                                  return vt;
                                }
    )
    | k = <TK_TRUE> 			      { return Literal.LTrue; }
    | k = <TK_FALSE>			      { return Literal.LFalse; }
  )
                                {
                                  if (ASSyntax.isKeyword(F))
                                    NS = Literal.DefaultNS;
                                  NS = nsDirective.map(NS);

                                  if (F.getFunctor().charAt(0) == '\'') {
                                    //F = (Pred)F.newFunctor(F.getFunctor().substring(1, F.getFunctor().length()-1));
                                  } else {
                                    if (F.getFunctor().indexOf(".") >= 0) {
                                      if (F.hasAnnot())
                                        throw new ParseException(getSourceRef(F)+" Internal actions cannot have annotations.");
                                      if (type == Literal.LNeg)
                                        throw new ParseException(getSourceRef(F)+" Internal actions cannot be negated.");
                                      try {
                                        if (F.getFunctor().equals(".include")) // .include needs a namespace (see its code)
                                          return new InternalActionLiteral(NS, F, curAg);
                                        else
                                          return new InternalActionLiteral(F, curAg);
                                      } catch (Exception e) {
                                        if (getArithFunction(F) == null) // it is not a registered function
                                          logger.warning(getSourceRef(F)+" warning: The internal action class for '"+F+"' was not loaded! Error: "+e);
                                      }
                                    }
                                  }

                                  return new LiteralImpl(NS, type, F);
                                }
}


Atom namespace() :
{
  Atom NS = namespace; Token tns = null; boolean explicitAbstractNS = true;
}
{
  [
    tns = <ATOM>                    { if (tns.image.equals("default"))
                                           NS = Literal.DefaultNS;
                                      else if (tns.image.equals("this_ns"))
                                           NS = thisnamespace;
                                      else
                                           NS = ASSyntax.createAtom(tns.image);
                                      explicitAbstractNS = false;
                                    }
    | NS = var(Literal.DefaultNS)  { if (NS.hasAnnot())
                                        throw new ParseException(getSourceRef(NS)+" name space cannot have annotations.");
                                      explicitAbstractNS = false;
                                    }
  ]
  <TK_NS_SEP>                       { if (explicitAbstractNS)
                                        NS = thisnamespace;
                                      return NS;
                                    }
}


/* Annotated Formulae */
Pred pred() :          { Token K; Pred p; List l; ListTerm lt; Term b;
                         Atom ons = namespace; namespace = Literal.DefaultNS; // do not replace abstract namespace for terms
                       }
{
  (
   K=<ATOM>
   |
   K=<TK_BEGIN>
   |
   K=<TK_END>
  )
                       { p = new Pred(K.image);
                         p.setSrcInfo(new SourceInfo(asSource, K.beginLine));
                       }

  [
    "(" l = terms()
    ")"                { p.setTerms(l); }
  ]
  [
    lt = list()        { p.setAnnots(lt); }
  ]
                       { namespace = ons;
                         return p;
                       }
}


/* List of terms */
List terms() :    { ArrayList listTerms = new ArrayList(); Term v; PlanBody o; }
{
  v=term()             { listTerms.add(v); }
  ( "," v=term()       { listTerms.add(v); }
  )*
                       { listTerms.trimToSize();
                         return listTerms;
                       }
}


Term term() :          { Object o; }
{
  o=log_expr()         // log_expr includes literals/atoms/structures
                       { return changeToAtom(o); }
}


ListTermImpl list() :     { ListTermImpl lt = new ListTermImpl(); ListTerm last = lt; Token K; Term f;
                            Atom ons = namespace; namespace = Literal.DefaultNS; // do not replace abstract namespace for terms
                          }
{
  "["
  [ f=term_in_list()      { last = lt.append(f); lt.setSrcInfo(f.getSrcInfo()); }
    ( "," f=term_in_list(){ last = last.append(f); }
    )*
  ]
  [ "|"  ( K=<VAR>        { last.setNext(new VarTerm(K.image)); }
         | K=<UNNAMEDVAR> { last.setNext(UnnamedVar.create(K.image)); }
         | f=list()       { last = last.concat((ListTerm)f); }
         )
  ]
  "]"                     { namespace = ons;
                            return lt;
                          }
}


// term_in_list is the same as term, but log_expr/plan_body must be enclosed by "("....")" to avoid problem with |
Term term_in_list() :     { Object o; }
{
  ( o=list()
  | o=arithm_expr()
  | o=string()
  | o=rule_plan_term()
  )
                          { return changeToAtom(o); }
}


/* logical expression */
Object log_expr() :         { Object t1, t2; }
{
   t1 = log_expr_trm()
   [  "|" t2 = log_expr()   { return new LogExpr((LogicalFormula)t1,LogicalOp.or,(LogicalFormula)t2); } ]
                            { return t1; }
}

Object log_expr_trm() :     { Object t1, t2; }
{
   t1 = log_expr_factor()
[  "&" t2 = log_expr_trm()  { return new LogExpr((LogicalFormula)t1,LogicalOp.and,(LogicalFormula)t2); } ]
                            { return t1; }
}


Object log_expr_factor() :
{
  Object t; boolean hasNot = false;
}
{
  [
    <TK_NOT>        { hasNot = true; }
  ]
  t = rel_expr()    { if(hasNot)
                        return new LogExpr(LogicalOp.not,(LogicalFormula)t);
                      return t;
                    }
}


/* relational expression
   used in context, body and term

     <VAR>      [ <OPREL> <EXP> ]  --> this method returns the VarTerm
   | <LITERAL>  [ <OPREL> <EXP> ]  --> returns the Literal
   | <EXP>      [ <OPREL> <EXP> ]  --> returns the ExprTerm
*/
Object rel_expr() :
                                          {  Object op1 = null;
                                             Object op2 = null;
                                             RelationalOp operator = RelationalOp.none;
                                           }
{
    (   op1 = arithm_expr()
      | op1 = string()
      | op1 = list()
      | op1 = rule_plan_term()
    )

    [
       ( "<"                               { operator = RelationalOp.lt; }
       | "<="                              { operator = RelationalOp.lte; }
       | ">"                               { operator = RelationalOp.gt; }
       | ">="                              { operator = RelationalOp.gte; }
       | "=="                              { operator = RelationalOp.eq; }
       | "\\=="                            { operator = RelationalOp.dif; }
       | "="                               { operator = RelationalOp.unify; }
       | "=.."                             { operator = RelationalOp.literalBuilder; }
       )

       (   op2 = arithm_expr()
         | op2 = string()
         | op2 = list()
         | op2 = rule_plan_term()
       )

                                           { //if ( ((Term)op1).isInternalAction() && operator != RelationalOp.literalBuilder)
                                             //   throw new ParseException(getSourceRef(op1)+" RelExpr: operand '"+op1+"' can not be an internal action.");
                                             //if ( ((Term)op2).isInternalAction() && operator != RelationalOp.literalBuilder)
                                             //   throw new ParseException(getSourceRef(op2)+" RelExpr: operand '"+op2+"' can not be an internal action.");

                                             // remove namespace (if not defined), args of rel ops are terms (not literals)
                                             if (op1 instanceof Literal) {
                                             	Literal l = (Literal)op1;
                                             	if (!l.getNS().equals(Literal.DefaultNS) && l.getNS().equals(namespace)) {
                                             		op1 = l.cloneNS(Literal.DefaultNS);
                                             	}
                                             }
                                             if (op2 instanceof Literal) {
                                             	Literal l = (Literal)op2;
                                             	if (!l.getNS().equals(Literal.DefaultNS) && l.getNS().equals(namespace)) {
                                             		op2 = l.cloneNS(Literal.DefaultNS);
                                             	}
                                             }
                                             return new RelExpr((Term)op1, operator, (Term)op2);
                                           }
    ]
                                           { return op1; }
}


/* arithmetic expression */
Object arithm_expr() :        { Object t1, t2; ArithmeticOp op; }
{
   t1 = arithm_expr_trm()     { op = ArithmeticOp.none; }
   (  ( "+"                      { op = ArithmeticOp.plus;}
      | "-"                      { op = ArithmeticOp.minus;}
      )
      t2 = arithm_expr_trm()     { if (!(t1 instanceof NumberTerm)) {
                                      throw new ParseException(getSourceRef(t1)+" ArithExpr: first operand '"+t1+"' is not numeric or variable.");
                                   }
                                   if (!(t2 instanceof NumberTerm)) {
                                      throw new ParseException(getSourceRef(t2)+" ArithExpr: second operand '"+t2+"' is not numeric or variable.");
                                   }
                                   t1 = new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2);
                                }
   )*                           { return t1; }
}

Object arithm_expr_trm() :      { Object t1, t2; ArithmeticOp op; }
{
   t1 = arithm_expr_factor()    { op = ArithmeticOp.none; }
(  ( "*"                        { op = ArithmeticOp.times; }
   | "/"                        { op = ArithmeticOp.div; }
   | <TK_INTDIV>                { op = ArithmeticOp.intdiv; }
   | <TK_INTMOD>                { op = ArithmeticOp.mod; }
   )
   t2 = arithm_expr_factor()    { if (!(t1 instanceof NumberTerm)) {
                                    throw new ParseException(getSourceRef(t1)+" ArithTerm: first operand '"+t1+"' is not numeric or variable.");
                                  }
                                  if (!(t2 instanceof NumberTerm)) {
                                    throw new ParseException(getSourceRef(t2)+" ArithTerm: second operand '"+t2+"' is not numeric or variable.");
                                  }
                                  t1 = new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2);
                                }
)*                              { return t1; }
}

Object arithm_expr_factor():
                                { Object t1, t2; ArithmeticOp op;}
{
   t1 = arithm_expr_simple()    { op = ArithmeticOp.none; }
[  ( "**"                       { op = ArithmeticOp.pow; }
   )
   t2 = arithm_expr_factor()    { if (!(t1 instanceof NumberTerm)) {
                                    throw new ParseException(getSourceRef(t1)+" ArithFactor: first operand '"+t1+"' is not numeric or variable.");
                                  }
                                  if (!(t2 instanceof NumberTerm)) {
                                    throw new ParseException(getSourceRef(t2)+" ArithFactor: second operand '"+t2+"' is not numeric or variable.");
                                  }
                                  return new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2);
                                }
]                               { return t1; }
}


Object arithm_expr_simple() :
{
  Token K; Object t = null; ArithmeticOp op = ArithmeticOp.none;
}
{
  [
    "+"                           { op = ArithmeticOp.plus; }
    | "-"                         { op = ArithmeticOp.minus; }
  ]
  (
    K = <NUMBER>                  { NumberTerm ni = ASSyntax.parseNumber(K.image);
                                    ni.setSrcInfo(new SourceInfo(asSource, K.beginLine));
                                    if (op == ArithmeticOp.none) {
                                      return ni;
                                    }
                                    return new ArithExpr(op, ni);
                                  }
    | ( "(" t = log_expr() ")" )
    | t = function()
  )
                                  {
                                    if (op != ArithmeticOp.none) {
                                      if (!(t instanceof NumberTerm)) {
                                        throw new ParseException(getSourceRef(t)+" The argument '"+t+"' of operator '"+op.toString()+"' is not numeric or variable.");
                                      }
                                      return new ArithExpr(op, (NumberTerm)t);
                                    }
                                    return t;
                                  }
}


Term function():          { Literal l; }
{
   l = literal()
                          { ArithFunction af = getArithFunction(l);
                            if (af == null) {
                               return l;
                            } else {
                               ArithFunctionTerm at = new ArithFunctionTerm(af);
                               at.setSrcInfo(l.getSrcInfo());
                               at.setTerms(l.getTerms());
                               at.setAgent(curAg);
                               return at;
                            }
                          }
}


VarTerm var(Atom ns):      { Token K; VarTerm v; ListTerm lt = null; }
{
 ( K = <VAR>          { v = new VarTerm(ns, K.image); v.setSrcInfo(new SourceInfo(asSource, K.beginLine));}
 | K = <UNNAMEDVARID> { Matcher matcher = patternUnnamedWithId.matcher(K.image);
                        if (matcher.find()) {
                            v = UnnamedVar.create(ns, Integer.parseInt(matcher.group(1)), K.image);
                        } else {
        	                v = UnnamedVar.create(ns, K.image);
                        }
                      }
 | K = <UNNAMEDVAR>   { v = UnnamedVar.create(ns, K.image); }
 )
 [
   lt = list()      { v.setAnnots(lt); }
 ]
                    { return v;
                    }
}

StringTerm string():{ Token k; StringTermImpl s; }
{
  k = <STRING>      { s = new StringTermImpl(k.image.substring(1,k.image.length()-1).replaceAll("\\\\n", "\n").replaceAll("\\\\\"","\"") );
                      s.setSrcInfo(new SourceInfo(asSource,k.beginLine));
                      return s;
                    }
}
